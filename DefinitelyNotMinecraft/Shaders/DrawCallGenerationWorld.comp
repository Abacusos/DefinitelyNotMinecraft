
#extension GL_EXT_shader_8bit_storage : require
#extension GL_KHR_shader_subgroup_ballot: enable
#extension GL_KHR_shader_subgroup_arithmetic: enable

struct DrawCall
{
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
    uint globalIndexTransform;
    uint globalIndexFace;
};

layout (std140, binding = 0) readonly uniform projectionBuffer
{
    mat4 projection;
};

layout (std140, binding = 1) readonly uniform viewBuffer
{
    mat4 view;
    vec4 cameraPos;
};

layout (std140, binding = 2) buffer transformBuffer
{
    vec4 transforms[];
};

struct BlockData{
    uint index;
    uint8_t blockType;
    uint8_t visibleFace;
    uint8_t padding;
    uint8_t padding2;
};

layout (std430, binding = 3) buffer blockTypeBuffer
{
    BlockData blockData[];
};

layout (std430, binding = 4) readonly buffer worldDataBuffer
{
    uint8_t blockTypeWorld[];
};

layout (binding = 5) buffer drawCallBuffer
{
    DrawCall drawcall;
};

layout (binding = 6) readonly uniform chunkConstants
{
    int chunkLoadCount;
    int chunksOneDimension;
    int chunkLocalSize;
    int chunkHeight;
};

layout (binding = 7) readonly buffer chunkIndexRemap
{
    uint remapIndex[];
};

struct Plane
{
    vec3 normal;
    float dist;
};

layout (binding = 8) readonly uniform cullingData
{
	Plane planes[6];
	uint cullingEnabled;
};

vec3 indexToPos()
{
  int remap = int(remapIndex[gl_WorkGroupID.x]);
  int remapOffsetX = (remap % chunksOneDimension) - chunkLoadCount;
  int remapOffsetZ = (remap / chunksOneDimension) - chunkLoadCount;
  int chunkStartX = int(chunkLocalSize * (remapOffsetX + int(cameraPos.x / chunkLocalSize)));
  int chunkStartZ = int(chunkLocalSize * (remapOffsetZ + int(cameraPos.z / chunkLocalSize)));
  int x = int(gl_LocalInvocationID.x) + chunkStartX;
  int z = int(gl_LocalInvocationID.z) + chunkStartZ;

  return vec3(x, gl_WorkGroupID.y, z);
}

bool isInsideChunk(ivec3 position)
{
    return position.y >= 0 && position.y < chunkHeight && position.x >= 0 && position.x < chunkLocalSize && position.z >= 0 && position.z < chunkLocalSize;
}

uint toFlatIndex(ivec3 position)
{
  int remap = int(remapIndex[gl_WorkGroupID.x]);
  int chunkStartX = (remap % chunksOneDimension);
  int chunkStartZ = (remap / chunksOneDimension);
  
  int heightOffset = chunkLocalSize * chunkLocalSize * position.y;
  
  int sizeOfChunk = chunkLocalSize * chunkLocalSize * chunkHeight;
  int offsetPreviousChunk = chunkStartX * sizeOfChunk + chunkStartZ * chunksOneDimension * sizeOfChunk;
   
   // Convert any world space positions into chunk local positions
  int inLayerOffset = (position.z % chunkLocalSize) * chunkLocalSize + (position.x % chunkLocalSize);

  return offsetPreviousChunk + heightOffset + inLayerOffset;
}

float getSignedDistanceToPlane(const vec3 point, const Plane plane)
{
    return dot(plane.normal, point) - plane.dist;
}

bool isVisible(vec3 center, float extent)
{
	bool visible = true;

    for(int i = 0; i < 6; ++i)
    {	
        const float r = dot(abs(planes[i].normal), vec3(extent));
        visible = visible && -r <= getSignedDistanceToPlane(center, planes[i]);
    }

	visible = visible || cullingEnabled == 0;
    return visible;
}

const ivec3 direction[6] = ivec3[](
    ivec3(-1, 0, 0),
    ivec3(0, 0, 1),
    ivec3(0, 1, 0),
    ivec3(0, -1, 0),
    ivec3(1, 0, 0),
    ivec3(0, 0, -1)
);

// Reduce the number of visible faces to avoid z fighting
uint[6] getVisibleFaces(in ivec3 center, out uint faceCount)
{
    faceCount = 0;

    uint[6] result;

    for(int i = 0; i < 6; ++i)
    {
        ivec3 neighbor = ivec3(center.x % chunkLocalSize, center.y, center.z % chunkLocalSize);
        neighbor += direction[i];
        bool neighborIsInsideChunk = isInsideChunk(neighbor);
        bool neighborIsAir = neighborIsInsideChunk ? uint(blockTypeWorld[toFlatIndex(neighbor)]) == uint(255) : false;
        if(!neighborIsInsideChunk || (neighborIsInsideChunk && neighborIsAir))
        {
            result[faceCount] = i;
            ++faceCount;
        }
    }

    return result;
}

layout (local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y, local_size_z = LOCAL_SIZE_Z) in;

uint highestBitSet = uint(128);

void main()
{
  uint blockIndex = toFlatIndex(ivec3(int(gl_LocalInvocationID.x), int(gl_WorkGroupID.y), int(gl_LocalInvocationID.z)));

  uint block = uint(blockTypeWorld[blockIndex]);
  if(block == uint(255) || (block & uint(128)) != 0u)
  {
    return;
  }
  
  vec3 position = indexToPos();

  uint instanceVisible = isVisible(vec3(position.x + 0.5f, position.y + 0.5f, position.z + 0.5f), 0.5f) ? 1 : 0;

  uint visibleFacesCount;
  uint[6] visibleFaces = getVisibleFaces(ivec3(int(position.x), int(position.y), int(position.z)), visibleFacesCount);
  visibleFacesCount = instanceVisible == 1 ? visibleFacesCount : 0u;

  uint localIndex = subgroupExclusiveAdd(visibleFacesCount);
  uint transformLocalIndex = subgroupExclusiveAdd(instanceVisible);

  uint highestActiveID = subgroupBallotFindMSB(subgroupBallot(true));

  uint globalIndex = 0;
  uint transformGlobalIndex = 0;

  // If we're the highest active ID, carve out a chunk from the global index
  if (highestActiveID == gl_SubgroupInvocationID)
  {
    uint localSize = localIndex + visibleFacesCount;
    atomicAdd(drawcall.vertexCount, 6 * localSize);
    globalIndex = atomicAdd(drawcall.globalIndexFace, localSize);
    uint transformLocalSize = transformLocalIndex + instanceVisible;
    transformGlobalIndex = atomicAdd(drawcall.globalIndexTransform, transformLocalSize);
  }

  globalIndex = subgroupMax(globalIndex);
  transformGlobalIndex = subgroupMax(transformGlobalIndex);

  if(instanceVisible > 0)
  {
      for(uint i = 0u; i < visibleFacesCount; ++i)
      {
          blockData[globalIndex + localIndex + i].index = transformGlobalIndex + transformLocalIndex;
          blockData[globalIndex + localIndex + i].blockType = uint8_t(block);
          blockData[globalIndex + localIndex + i].visibleFace = uint8_t(visibleFaces[i]);
      }
      transforms[transformGlobalIndex + transformLocalIndex] = vec4(position.x, position.y, position.z, 1.0f);
  }
}
